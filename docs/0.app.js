(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[function(e,t,n){"use strict";(function(e){Object.defineProperty(t,"__esModule",{value:!0});const{isConcatSpreadable:n}=Symbol,{isArray:o}=Array,{slice:r,unshift:a,shift:i}=Array.prototype;function s(e){if(!function(e){return"object"==typeof e?null!==e:"function"==typeof e}(e))return!1;const t=e[n];return void 0!==t?Boolean(t):o(e)}function l(...e){const t=Object(this),n=[];let o=0;const l=r.call(arguments);for(a.call(l,t);l.length;){const e=i.call(l);if(s(e)){let t=0;const r=e.length;for(;t<r;t+=1,o+=1)if(t in e){const r=e[t];n[o]=r}}else n[o]=e,o+=1}return n}function c(e){return void 0===Object.getOwnPropertyDescriptor(Element.prototype,e)}(function(){if("getKey"in Proxy)return!1;const e=new Proxy([3,4],{});return 4!==[1,2].concat(e).length})()&&(Array.prototype.concat=l);const{hasAttribute:u,getAttribute:d,setAttribute:f,setAttributeNS:h,removeAttribute:p,removeAttributeNS:m}=Element.prototype,g=/^aria/,y=new WeakMap,{hasOwnProperty:b}=Object.prototype,{replace:v,toLowerCase:w}=String.prototype;function $(e){let t=y.get(e);return void 0===t&&(t={},y.set(e,t)),t}function T(e){const t=v.call(e,g,"aria-"),n=function(e,t){return{get(){const n=$(this);return b.call(n,e)?n[e]:u.call(this,t)?d.call(this,t):null},set(n){const o=null==(r=n)?null:r+"";var r;$(this)[e]=o,null===n?p.call(this,t):f.call(this,t,n)},configurable:!0,enumerable:!0}}(e,w.call(t));Object.defineProperty(Element.prototype,e,n)}const E=["ariaAutoComplete","ariaChecked","ariaCurrent","ariaDisabled","ariaExpanded","ariaHasPopup","ariaHidden","ariaInvalid","ariaLabel","ariaLevel","ariaMultiLine","ariaMultiSelectable","ariaOrientation","ariaPressed","ariaReadOnly","ariaRequired","ariaSelected","ariaSort","ariaValueMax","ariaValueMin","ariaValueNow","ariaValueText","ariaLive","ariaRelevant","ariaAtomic","ariaBusy","ariaActiveDescendant","ariaControls","ariaDescribedBy","ariaFlowTo","ariaLabelledBy","ariaOwns","ariaPosInSet","ariaSetSize","ariaColCount","ariaColIndex","ariaDetails","ariaErrorMessage","ariaKeyShortcuts","ariaModal","ariaPlaceholder","ariaRoleDescription","ariaRowCount","ariaRowIndex","ariaRowSpan","ariaColSpan","role"];for(let e=0,t=E.length;e<t;e+=1){const t=E[e];c(t)&&T(t)}var k=Object.freeze({__proto__:null,invariant:function(e,t){if(!e)throw new Error(`Invariant Violation: ${t}`)},isTrue:function(e,t){if(!e)throw new Error(`Assert Violation: ${t}`)},isFalse:function(e,t){if(e)throw new Error(`Assert Violation: ${t}`)},fail:function(e){throw new Error(e)}});const{assign:C,create:x,defineProperties:O,defineProperty:S,freeze:A,getOwnPropertyDescriptor:M,getOwnPropertyNames:L,getPrototypeOf:P,hasOwnProperty:I,keys:R,seal:H,setPrototypeOf:j}=Object,{isArray:N}=Array,{filter:D,find:F,forEach:_,indexOf:B,join:V,map:q,push:U,reduce:W,reverse:z,slice:K,splice:Y,unshift:G}=Array.prototype,{charCodeAt:J,replace:Q,slice:X,toLowerCase:Z}=String.prototype;function ee(e){return void 0===e}function te(e){return null===e}function ne(e){return!0===e}function oe(e){return!1===e}function re(e){return"function"==typeof e}function ae(e){return"object"==typeof e}function ie(e){return"string"==typeof e}const se={}.toString;function le(e){return e&&e.toString?N(e)?V.call(q.call(e,le),","):e.toString():"object"==typeof e?se.call(e):e+ue}function ce(e,t){do{const n=M(e,t);if(!ee(n))return n;e=P(e)}while(null!==e)}const ue="",de="Symbol(x)"===Symbol("x").toString();function fe(e,t){return de?Symbol(e):`$$lwc-${t}-${e}$$`}const he=new WeakMap;function pe(e,t,n){let o=he.get(e);ee(o)&&(o=x(null),he.set(e,o)),o[t]=n}function me(e,t){const n=he.get(e);if(!ee(n))return n[t]}const ge=["accessKey","dir","draggable","hidden","id","lang","tabIndex","title"];function ye(e){return`Using the \`${e}\` property is an anti-pattern because it rounds the value to an integer. Instead, use the \`getBoundingClientRect\` method to obtain fractional values for the size of an element and its position relative to the viewport.`}const be=C(x(null),{accessKey:{attribute:"accesskey"},accessKeyLabel:{readOnly:!0},className:{attribute:"class",error:"Using the `className` property is an anti-pattern because of slow runtime behavior and potential conflicts with classes provided by the owner element. Use the `classList` API instead."},contentEditable:{attribute:"contenteditable"},dataset:{readOnly:!0,error:"Using the `dataset` property is an anti-pattern because it can't be statically analyzed. Expose each property individually using the `@api` decorator instead."},dir:{attribute:"dir"},draggable:{attribute:"draggable"},dropzone:{attribute:"dropzone",readOnly:!0},hidden:{attribute:"hidden"},id:{attribute:"id"},inputMode:{attribute:"inputmode"},lang:{attribute:"lang"},slot:{attribute:"slot",error:"Using the `slot` property is an anti-pattern."},spellcheck:{attribute:"spellcheck"},style:{attribute:"style"},tabIndex:{attribute:"tabindex"},title:{attribute:"title"},translate:{attribute:"translate"},isContentEditable:{readOnly:!0},offsetHeight:{readOnly:!0,error:ye("offsetHeight")},offsetLeft:{readOnly:!0,error:ye("offsetLeft")},offsetParent:{readOnly:!0},offsetTop:{readOnly:!0,error:ye("offsetTop")},offsetWidth:{readOnly:!0,error:ye("offsetWidth")},role:{attribute:"role"}}),ve=x(null),we=x(null);_.call(E,e=>{const t=Z.call(Q.call(e,/^aria/,"aria-"));ve[t]=e,we[e]=t}),_.call(ge,e=>{const t=Z.call(e);ve[t]=e,we[e]=t}),_.call(["accessKey","readOnly","tabIndex","bgColor","colSpan","rowSpan","contentEditable","dateTime","formAction","isMap","maxLength","useMap"],e=>{const t=Z.call(e);ve[t]=e,we[e]=t});const $e=/-([a-z])/g;const Te=/[A-Z]/g;function Ee(e){return ee(we[e])&&(we[e]=Q.call(e,Te,e=>"-"+e.toLowerCase())),we[e]}let ke,Ce=null;function xe(e,t){Ce=null,ke=void 0}function Oe(e,t){Ce=e,ke=t}let Se=[];const Ae=H(x(null)),Me=H([]);function Le(){if(0===Se.length)throw new Error("Internal Error: If callbackQueue is scheduled, it is because there must be at least one callback on this pending queue.");const e=Se;Se=[];for(let t=0,n=e.length;t<n;t+=1)e[t]()}function Pe(e){if(!re(e))throw new Error("Internal Error: addCallbackToNextTick() can only accept a function callback");0===Se.length&&Promise.resolve().then(Le),U.call(Se,e)}function Ie(e){return I.call(e,"__circular__")}function Re(e){if(!re(e))throw new TypeError("Circular module dependency must be a function.");return e()}const He=I.call(Element.prototype,"$shadowToken$");function je(e){try{return`<${Z.call(e.elm.tagName)}>`}catch(e){return"<invalid-tag-name>"}}function Ne(e){const t=[];let n=e;for(;!te(n);)U.call(t,je(n)),n=n.owner;return t.reverse().join("\n\t")}function De(e,t){let n=`[LWC error]: ${e}`;ee(t)||(n=`${n}\n${function(e){const t=[];let n="";for(;!te(e.owner);)U.call(t,n+je(e)),e=e.owner,n+="\t";return V.call(t,"\n")}(t)}`);try{throw new Error(n)}catch(e){console.error(e)}}function Fe(e){const{data:{on:t}}=e;if(ee(t))return;const n=e.elm,o=e.listener=function e(t){!function(e,t){const{type:n}=e,{data:{on:o}}=t,r=o&&o[n];r&&r.call(void 0,e)}(t,e.vnode)};let r;for(r in o.vnode=e,t)n.addEventListener(r,o)}var _e={update:function(e,t){ee(e.listener)?Fe(t):(t.listener=e.listener,t.listener.vnode=t)},create:Fe};function Be(e,t){const{data:{attrs:n}}=t;if(ee(n))return;let{data:{attrs:o}}=e;if(o===n)return;k.invariant(ee(o)||R(o).join(",")===R(n).join(","),"vnode.data.attrs cannot change shape.");const r=t.elm;let a;for(a in o=ee(o)?Ae:o,n){const e=n[a];o[a]!==e&&(Oe(r,a),58===J.call(a,3)?r.setAttributeNS("http://www.w3.org/XML/1998/namespace",a,e):58===J.call(a,5)?r.setAttributeNS("http://www.w3.org/1999/xlink",a,e):te(e)?r.removeAttribute(a):r.setAttribute(a,e),xe())}}const Ve={data:{}};var qe={create:e=>Be(Ve,e),update:Be};function Ue(e,t){return"input"===e&&("value"===t||"checked"===t)}function We(e,t){const n=t.data.props;if(ee(n))return;const o=e.data.props;if(o===n)return;k.invariant(ee(o)||R(o).join(",")===R(n).join(","),"vnode.data.props cannot change shape.");const r=t.elm,a=ee(o),{sel:i}=t;for(const e in n){const t=n[e];e in r||k.fail(`Unknown public property "${e}" of element <${i}>. This is likely a typo on the corresponding attribute "${Ee(e)}".`),(a||t!==(Ue(i,e)?r[e]:o[e]))&&(r[e]=t)}}const ze={data:{}};var Ke={create:e=>We(ze,e),update:We};const Ye=x(null);function Ge(e){if(null==e)return Ae;e=ie(e)?e:e+"";let t=Ye[e];if(t)return t;t=x(null);let n,o=0;const r=e.length;for(n=0;n<r;n++)32===J.call(e,n)&&(n>o&&(t[X.call(e,o,n)]=!0),o=n+1);return n>o&&(t[X.call(e,o,n)]=!0),Ye[e]=t,A(t),t}function Je(e,t){const{elm:n,data:{className:o}}=t,{data:{className:r}}=e;if(r===o)return;const{classList:a}=n,i=Ge(o),s=Ge(r);let l;for(l in s)ee(i[l])&&a.remove(l);for(l in i)ee(s[l])&&a.add(l)}const Qe={data:{}};var Xe={create:e=>Je(Qe,e),update:Je};function Ze(e,t){const{style:n}=t.data;if(e.data.style===n)return;const o=t.elm,{style:r}=o;ie(n)&&""!==n?r.cssText=n:p.call(o,"style")}const et={data:{}};var tt={create:e=>Ze(et,e),update:Ze};var nt={create:function(e){const{elm:t,data:{classMap:n}}=e;if(ee(n))return;const{classList:o}=t;for(const e in n)o.add(e)}};var ot={create:function(e){const{elm:t,data:{styleMap:n}}=e;if(ee(n))return;const{style:o}=t;for(const e in n)o[e]=n[e]}};const rt={create:function(e){const{data:{context:t}}=e;if(ee(t))return;const n=zr(e.elm);ee(n)||C(n.context,t)}};
/**
@license
Copyright (c) 2015 Simon Friis Vindum.
This code may only be used under the MIT License found at
https://github.com/snabbdom/snabbdom/blob/master/LICENSE
Code distributed by Snabbdom as part of the Snabbdom project at
https://github.com/snabbdom/snabbdom/
*/function at(e){return void 0===e}function it(e,t){return e.key===t.key&&e.sel===t.sel}function st(e){return null!=e}function lt(e,t,n){const o={};let r,a,i;for(r=t;r<=n;++r)i=e[r],st(i)&&(a=i.key,void 0!==a&&(o[a]=r));return o}function ct(e,t,n,o,r){for(;o<=r;++o){const r=n[o];st(r)&&(r.hook.create(r),r.hook.insert(r,e,t))}}function ut(e,t,n){let o,r,a,i,s=0,l=0,c=t.length-1,u=t[0],d=t[c],f=n.length-1,h=n[0],p=n[f];for(;s<=c&&l<=f;)st(u)?st(d)?st(h)?st(p)?it(u,h)?(ft(u,h),u=t[++s],h=n[++l]):it(d,p)?(ft(d,p),d=t[--c],p=n[--f]):it(u,p)?(ft(u,p),p.hook.move(u,e,d.elm.nextSibling),u=t[++s],p=n[--f]):it(d,h)?(ft(d,h),h.hook.move(d,e,u.elm),d=t[--c],h=n[++l]):(void 0===o&&(o=lt(t,s,c)),r=o[h.key],at(r)?(h.hook.create(h),h.hook.insert(h,e,u.elm),h=n[++l]):(a=t[r],st(a)&&(a.sel!==h.sel?(h.hook.create(h),h.hook.insert(h,e,u.elm)):(ft(a,h),t[r]=void 0,h.hook.move(a,e,u.elm))),h=n[++l])):p=n[--f]:h=n[++l]:d=t[--c]:u=t[++s];if(s<=c||l<=f)if(s>c){const t=n[f+1];i=st(t)?t.elm:null,ct(e,i,n,l,f)}else!function(e,t,n,o){for(;n<=o;++n){const o=t[n];st(o)&&o.hook.remove(o,e)}}(e,t,s,c)}function dt(e,t,n){const{length:o}=n;if(0===t.length)return void ct(e,null,n,0,o);let r=null;for(let a=o-1;a>=0;a-=1){const o=n[a],i=t[a];o!==i&&(st(i)?st(o)?(ft(i,o),r=o.elm):i.hook.remove(i,e):st(o)&&(o.hook.create(o),o.hook.insert(o,e,r),r=o.elm))}}function ft(e,t){e!==t&&(t.elm=e.elm,t.hook.update(e,t))}function ht(e){return C({configurable:!0,enumerable:!0,writable:!0},e)}function pt(e){return C({configurable:!0,enumerable:!0},e)}let mt=!1;function gt(){mt=!0}function yt(){mt=!1}function bt(e,t){return`The \`${e}\` ${t} is available only on elements that use the \`lwc:dom="manual"\` directive.`}function vt(e,t){const n=ce(e,"textContent"),o=ce(e,"nodeValue"),{appendChild:r,insertBefore:a,removeChild:i,replaceChild:s}=e;return{appendChild:ht({value(e){return this instanceof Element&&oe(t.isPortal)&&De(bt("appendChild","method")),r.call(this,e)}}),insertBefore:ht({value(e,n){return!mt&&this instanceof Element&&oe(t.isPortal)&&De(bt("insertBefore","method")),a.call(this,e,n)}}),removeChild:ht({value(e){return!mt&&this instanceof Element&&oe(t.isPortal)&&De(bt("removeChild","method")),i.call(this,e)}}),replaceChild:ht({value(e,n){return this instanceof Element&&oe(t.isPortal)&&De(bt("replaceChild","method")),s.call(this,e,n)}}),nodeValue:pt({get(){return o.get.call(this)},set(e){!mt&&this instanceof Element&&oe(t.isPortal)&&De(bt("nodeValue","property")),o.set.call(this,e)}}),textContent:pt({get(){return n.get.call(this)},set(e){this instanceof Element&&oe(t.isPortal)&&De(bt("textContent","property")),n.set.call(this,e)}})}}function wt(e){const t=e.dispatchEvent,n=M(e,"isConnected").get,o={dispatchEvent:ht({value(e){const n=Wr(this);if(k.isFalse(Mn(n),"this.dispatchEvent() should not be called during the construction of the custom"+` element for ${je(n)} because no one is listening just yet.`),!te(e)&&ae(e)){const{type:t}=e;/^[a-z][a-z0-9_]*$/.test(t)||De(`Invalid event type "${t}" dispatched in element ${je(n)}.`+" Event name must start with a lowercase letter and followed only lowercase letters, numbers, and underscores",n)}return t.apply(this,arguments)}}),isConnected:pt({get(){const e=Wr(this),t=je(e);return k.isFalse(Mn(e),"this.isConnected should not be accessed during the construction phase of the custom"+` element ${t}. The value will always be`+" false for Lightning Web Components constructed using lwc.createElement()."),k.isFalse(function(e){return e===En}(e),"this.isConnected should not be accessed during the rendering phase of the custom"+` element ${t}. The value will always be true.`),k.isFalse(function(e){return Ln===e}(e),"this.isConnected should not be accessed during the renderedCallback of the custom"+` element ${t}. The value will always be true.`),n.call(this)}})};return _.call(L(be),t=>{t in e||(o[t]=pt({get(){const{error:e,attribute:n}=be[t],o=[];o.push(`Accessing the global HTML property "${t}" is disabled.`),e?o.push(e):n&&o.push(`Instead access it via \`this.getAttribute("${n}")\`.`),De(o.join("\n"),Wr(this))},set(){const{readOnly:e}=be[t];e&&De(`The global HTML property \`${t}\` is read-only.`,Wr(this))}}))}),o}function $t(e){e.$fromTemplate$=!0}function Tt(e,t){O(e,function(e,t){const n=vt(e,t),o=ce(e,"innerHTML"),r=ce(e,"outerHTML");return C(n,{innerHTML:pt({get(){return o.get.call(this)},set(e){return oe(t.isPortal)&&De(bt("innerHTML","property"),zr(this)),o.set.call(this,e)}}),outerHTML:pt({get(){return r.get.call(this)},set(e){throw new TypeError("Invalid attempt to set outerHTML on Element.")}})}),n}(e,t))}function Et(e,t){O(e,function(e,t){const n=e.querySelector,o=e.querySelectorAll,r=e.addEventListener,a=vt(e,t),i=ce(e,"innerHTML"),s=ce(e,"textContent");return C(a,{innerHTML:pt({get(){return i.get.call(this)},set(e){throw new TypeError("Invalid attempt to set innerHTML on ShadowRoot.")}}),textContent:pt({get(){return s.get.call(this)},set(e){throw new TypeError("Invalid attempt to set textContent on ShadowRoot.")}}),addEventListener:ht({value(t,n,o){const a=kn();return k.invariant(!Sn,`${a}.render() method has side effects on the state of ${le(e)} by adding an event listener for "${t}".`),k.invariant(!Tn,`Updating the template of ${a} has side effects on the state of ${le(e)} by adding an event listener for "${t}".`),ee(o)||De("The `addEventListener` method in `LightningElement` does not support any options.",zr(this)),r.apply(this,arguments)}}),querySelector:ht({value(){const e=Wr(this);return k.isFalse(Mn(e),"this.template.querySelector() cannot be called during the construction of the"+`custom element for ${e} because no content has been rendered yet.`),n.apply(this,arguments)}}),querySelectorAll:ht({value(){const e=Wr(this);return k.isFalse(Mn(e),"this.template.querySelectorAll() cannot be called during the construction of the"+` custom element for ${e} because no content has been rendered yet.`),o.apply(this,arguments)}})}),_.call(L({cloneNode:0,getElementById:0,getSelection:0,elementsFromPoint:0,dispatchEvent:0}),e=>{const t=pt({get(){throw new Error(`Disallowed method "${e}" in ShadowRoot.`)}});a[e]=t}),a}(e,t))}function kt(e,t){const n=function(e,t){const n=vt(e,t),o=e.addEventListener,r=ce(e,"innerHTML"),a=ce(e,"outerHTML"),i=ce(e,"textContent");return C(n,{innerHTML:pt({get(){return r.get.call(this)},set(e){throw new TypeError("Invalid attempt to set innerHTML on HTMLElement.")}}),outerHTML:pt({get(){return a.get.call(this)},set(e){throw new TypeError("Invalid attempt to set outerHTML on HTMLElement.")}}),textContent:pt({get(){return i.get.call(this)},set(e){throw new TypeError("Invalid attempt to set textContent on HTMLElement.")}}),addEventListener:ht({value(t,n,r){const a=kn();return k.invariant(!Sn,`${a}.render() method has side effects on the state of ${le(this)} by adding an event listener for "${t}".`),k.invariant(!Tn,`Updating the template of ${a} has side effects on the state of ${le(e)} by adding an event listener for "${t}".`),ee(r)||De("The `addEventListener` method in `LightningElement` does not support any options.",zr(this)),o.apply(this,arguments)}})})}(e,t),o=P(e);j(e,x(o,n))}function Ct(e){O(e,{tagName:pt({get(){throw new Error("Usage of property `tagName` is disallowed because the component itself does not know which tagName will be used to create the element, therefore writing code that check for that value is error prone.")},configurable:!0,enumerable:!1})})}const xt=()=>{};function Ot(e,t){e.$shadowToken$=t}function St(e,t){const{text:n}=t;e.text!==n&&(gt(),t.elm.nodeValue=n,yt())}function At(e,t,n){gt(),t.insertBefore(e.elm,n),yt()}function Mt(e,t){gt(),t.removeChild(e.elm),yt()}var Lt;function Pt(e){!function(e){Kr(e)}(Wr(e.elm))}function It(e,t){const{children:n,owner:o}=t,r=Dt(n)?ut:dt;Zr(o,o.owner,xt,()=>{r(t.elm,e.children,n)},xt)}function Rt(e){const t=Wr(e.elm),{children:n}=e;t.aChildren=n,ne(He)&&(!function(e,t){k.invariant(ae(e.cmpSlots),"When doing manual allocation, there must be a cmpSlots object available.");const{cmpSlots:n}=e,o=e.cmpSlots=x(null);for(let e=0,n=t.length;e<n;e+=1){const n=t[e];if(te(n))continue;const{data:r}=n,a=r.attrs&&r.attrs.slot||"",i=o[a]=o[a]||[];n.key=`@${a}:${n.key}`,U.call(i,n)}if(oe(e.isDirty)){const t=R(n);if(t.length!==R(o).length)return void Gn(e);for(let r=0,a=t.length;r<a;r+=1){const a=t[r];if(ee(o[a])||n[a].length!==o[a].length)return void Gn(e);const i=n[a],s=o[a];for(let t=0,n=o[a].length;t<n;t+=1)if(i[t]!==s[t])return void Gn(e)}}}(t,n),e.children=Me)}function Ht(e){const{elm:t,children:n}=e;for(let e=0;e<n.length;++e){const o=n[e];null!=o&&(o.hook.create(o),o.hook.insert(o,t,null))}}function jt(e){!function(e){k.isTrue(e.state===Pr.connected||e.state===Pr.disconnected,`${e} must have been connected.`);_r(e)}(Wr(e.elm))}!function(e){e.manual="manual"}(Lt||(Lt={}));const Nt=new WeakMap;function Dt(e){return Nt.has(e)}const Ft=x(null),_t=["wiring","locator","rendered","connected","disconnected"];function Bt(e,t){k.isTrue(N(t)&&t.length>0,"Optimize invokeServiceHook() to be invoked only when needed");const{component:n,data:o,def:r,context:a}=e;for(let e=0,i=t.length;e<i;++e)t[e].call(void 0,n,o,r,a)}const Vt=Symbol.iterator,qt={create:e=>{e.elm=document.createTextNode(e.text),Kt(e),$t(e.elm)},update:St,insert:At,move:At,remove:Mt},Ut={create:e=>{e.elm=document.createComment(e.text),Kt(e),$t(e.elm)},update:St,insert:At,move:At,remove:Mt},Wt={create:e=>{const{data:t,sel:n,clonedElement:o}=e,{ns:r}=t;ee(o)?e.elm=ee(r)?document.createElement(n):document.createElementNS(r,n):e.elm=o,Kt(e),$t(e.elm),function(e){const{owner:t}=e,n=e.elm;if(ne(He)){const{data:{context:o}}=e,{shadowAttribute:r}=t.context;ee(o)||ee(o.lwc)||o.lwc.dom!==Lt.manual||function(e){e.$domManual$=!0}(n),Ot(n,r)}{const{data:{context:t}}=e;Tt(n,{isPortal:!ee(t)&&!ee(t.lwc)&&t.lwc.dom===Lt.manual})}}(e),function(e){_e.create(e),qe.create(e),Ke.create(e),nt.create(e),ot.create(e),Xe.create(e),tt.create(e),rt.create(e)}(e)},update:(e,t)=>{!function(e,t){qe.update(e,t),Ke.update(e,t),Xe.update(e,t),tt.update(e,t)}(e,t),It(e,t)},insert:(e,t,n)=>{At(e,t,n),Ht(e)},move:(e,t,n)=>{At(e,t,n)},remove:(e,t)=>{Mt(e,t),function(e){const{children:t,elm:n}=e;for(let e=0,o=t.length;e<o;++e){const o=t[e];te(o)||o.hook.remove(o,n)}}(e)}},zt={create:e=>{const{sel:t}=e;e.elm=document.createElement(t),Kt(e),$t(e.elm),function(e){const t=e.elm;if(!ee(zr(t)))return;const{mode:n,ctor:o,owner:r}=e;if(Mr(t,Ar(o)),ne(He)){const{shadowAttribute:e}=r.context;Ot(t,e)}Vr(t,o,{mode:n,owner:r}),k.isTrue(N(e.children),"Invalid vnode for a custom element, it must have children defined."),kt(t,Ae)}(e),Rt(e),function(e){_e.create(e),qe.create(e),Ke.create(e),nt.create(e),ot.create(e),Xe.create(e),tt.create(e),rt.create(e)}(e)},update:(e,t)=>{!function(e,t){qe.update(e,t),Ke.update(e,t),Xe.update(e,t),tt.update(e,t)}(e,t),Rt(t),It(e,t),function(e){const t=Wr(e.elm);k.isTrue(N(e.children),"Invalid vnode for a custom element, it must have children defined."),Dr(t)}(t)},insert:(e,t,n)=>{At(e,t,n);const o=Wr(e.elm);k.isTrue(o.state===Pr.created,`${o} cannot be recycled.`),Jr(o),Ht(e),Pt(e)},move:(e,t,n)=>{At(e,t,n)},remove:(e,t)=>{Mt(e,t),jt(e)}};function Kt(e){e.elm.$shadowResolver$=e.owner.cmpRoot.$shadowResolver$}function Yt(e){U.call(kn().velements,e)}function Gt(e,t,n){const o=kn();k.isTrue(ie(e),"h() 1st argument sel must be a string."),k.isTrue(ae(t),"h() 2nd argument data must be an object."),k.isTrue(N(n),"h() 3rd argument children must be an array."),k.isTrue("key"in t,` <${e}> "key" attribute is invalid or missing for ${o}. Key inside iterator is either undefined or null.`),k.isFalse(t.className&&t.classMap,"vnode.data.className and vnode.data.classMap ambiguous declaration."),k.isFalse(t.styleMap&&t.style,"vnode.data.styleMap and vnode.data.style ambiguous declaration."),t.style&&!ie(t.style)&&De(`Invalid 'style' attribute passed to <${e}> is ignored. This attribute must be a string value.`,o),_.call(n,e=>{null!=e&&k.isTrue(e&&"sel"in e&&"data"in e&&"children"in e&&"text"in e&&"elm"in e&&"key"in e,`${e} is not a vnode.`)});const{key:r}=t;const a={sel:e,data:t,children:n,text:void 0,elm:void 0,key:r,hook:Wt,owner:o};return 3===e.length&&115===J.call(e,0)&&118===J.call(e,1)&&103===J.call(e,2)&&function e(t){const{data:n,children:o,sel:r}=t;if(n.ns="http://www.w3.org/2000/svg",N(o)&&"foreignObject"!==r)for(let t=0,n=o.length;t<n;++t){const n=o[t];null!=n&&n.hook===Wt&&e(n)}}(a),a}function Jt(e,t,n,o=Me){Ie(t)&&(t=Re(t));const r=kn();k.isTrue(ie(e),"c() 1st argument sel must be a string."),k.isTrue(re(t),"c() 2nd argument Ctor must be a function."),k.isTrue(ae(n),"c() 3nd argument data must be an object."),k.isTrue(3===arguments.length||N(o),"c() 4nd argument data must be an array."),k.isFalse(n.className&&n.classMap,"vnode.data.className and vnode.data.classMap ambiguous declaration."),k.isFalse(n.styleMap&&n.style,"vnode.data.styleMap and vnode.data.style ambiguous declaration."),n.style&&!ie(n.style)&&De(`Invalid 'style' attribute passed to <${e}> is ignored. This attribute must be a string value.`,r),4===arguments.length&&_.call(o,e=>{null!=e&&k.isTrue(e&&"sel"in e&&"data"in e&&"children"in e&&"text"in e&&"elm"in e&&"key"in e,`${e} is not a vnode.`)});const{key:a}=n;let i,s;const l={sel:e,data:n,children:o,text:i,elm:s,key:a,hook:zt,ctor:t,owner:r,mode:"open"};return Yt(l),l}function Qt(e){return{sel:void 0,data:Ae,children:void 0,text:e,elm:void 0,key:void 0,hook:qt,owner:kn()}}function Xt(e){const t=kn();if(te(t))throw new Error;const n=t;return function(t){Rn(n,e,n.component,t)}}const Zt=new Map;let en=0;function tn(e){var t;return k.isTrue(N(e),"sc() api can only work with arrays."),t=e,Nt.set(t,1),e}var nn=Object.freeze({__proto__:null,h:Gt,ti:function(e){const t=e>0&&!(ne(e)||oe(e));{const n=kn();t&&De(`Invalid tabindex value \`${le(e)}\` in template for ${n}. This attribute must be set to 0 or -1.`,n)}return t?0:e},s:function(e,t,n,o){k.isTrue(ie(e),"s() 1st argument slotName must be a string."),k.isTrue(ae(t),"s() 2nd argument data must be an object."),k.isTrue(N(n),"h() 3rd argument children must be an array."),ee(o)||ee(o[e])||0===o[e].length||(n=o[e]);const r=Gt("slot",t,n);return He&&tn(n),r},c:Jt,i:function(e,t){const n=[];tn(n);const o=kn();if(ee(e)||null===e)return De(`Invalid template iteration for value "${le(e)}" in ${o}. It must be an Array or an iterable Object.`,o),n;k.isFalse(ee(e[Vt]),`Invalid template iteration for value \`${le(e)}\` in ${o}. It must be an array-like object and not \`null\` nor \`undefined\`.`);const r=e[Vt]();k.isTrue(r&&re(r.next),`Invalid iterator function for "${le(e)}" in ${o}.`);let a,i,s=r.next(),l=0,{value:c,done:u}=s;for(a=x(null);!1===u;){s=r.next(),u=s.done;const e=t(c,l,0===l,u);N(e)?U.apply(n,e):U.call(n,e);{const t=N(e)?e:[e];_.call(t,e=>{if(!te(e)&&ae(e)&&!ee(e.sel)){const{key:t}=e;ie(t)||"number"==typeof t?(1===a[t]&&ee(i)&&(i=`Duplicated "key" attribute value for "<${e.sel}>" in ${o} for item number ${l}. A key with value "${e.key}" appears more than once in the iteration. Key values must be unique numbers or strings.`),a[t]=1):ee(i)&&(i=`Invalid "key" attribute value in "<${e.sel}>" in ${o} for item number ${l}. Set a unique "key" value on all iterated child elements.`)}})}l+=1,c=s.value}return ee(i)||De(i,o),n},f:function(e){k.isTrue(N(e),"flattening api can only work with arrays.");const t=e.length,n=[];tn(n);for(let o=0;o<t;o+=1){const t=e[o];N(t)?U.apply(n,t):U.call(n,t)}return n},t:Qt,p:function(e){return{sel:"!",data:Ae,children:void 0,text:e,elm:void 0,key:void 0,hook:Ut,owner:kn()}},d:function(e){return null==e?null:Qt(e)},b:Xt,fb:function(e){const t=kn();if(te(t))throw new Error;const n=t;return function(){return In(n,e,K.call(arguments))}},ll:function(e,t,n){const o=kn();if(te(o))throw new Error;const r=Xt(e);return function(e){const{context:{locator:a}}=o;if(!ee(a)){const{locator:e}=Ft;e&&(a.resolved={target:t,host:a.id,targetContext:re(n)&&n(),hostContext:re(a.context)&&a.context()},Bt(o,e))}r(e)}},k:function(e,t){switch(typeof t){case"number":case"string":return e+":"+t;case"object":k.fail(`Invalid key value "${t}" in ${kn()}. Key must be a string or number.`)}},gid:function(e){const t=kn();return ee(e)||""===e?(De(`Invalid id value "${e}". The id attribute must contain a non-empty string.`,t),e):te(e)?null:`${e}-${t.idx}`},fid:function(e){const t=kn();return ee(e)||""===e?(ee(e)&&De('Undefined url value for "href" or "xlink:href" attribute. Expected a non-empty string.',t),e):te(e)?null:/^#/.test(e)?`${e}-${t.idx}`:e},dc:function(e,t,n,o){if(k.isTrue(ie(e),"dc() 1st argument sel must be a string."),k.isTrue(ae(n),"dc() 3nd argument data must be an object."),k.isTrue(3===arguments.length||N(o),"dc() 4nd argument data must be an array."),null==t)return null;if(!Sr(t))throw new Error(`Invalid LWC Constructor ${le(t)} for custom element <${e}>.`);let r=Zt.get(t);return ee(r)&&(r=en++,Zt.set(t,r)),n.key=`dc:${r}:${n.key}`,Jt(e,t,n,o)},sc:tn});const on=new Set;function rn(){return[]}on.add(rn);const an=x(null);function sn(e){const t=document.createElement("style");return t.type="text/css",t.textContent=e,t}const ln=document.head||document.body||document,cn=x(null);function un(e,t,n,o,r){_.call(e,e=>{N(e)?un(e,t,n,o,r):r(e(t,n,o))})}function dn(e,t,n){if(k.isTrue(N(e),"Invalid stylesheets."),He){return un(e,`[${t}]`,`[${n}]`,!1,e=>{!function(e){if(ee(cn[e])){cn[e]=!0;const t=sn(e);ln.appendChild(t)}}(e)}),null}{let t="";return un(e,ue,ue,!0,e=>{t+=e}),function(e){const t=Gt("style",{key:"style"},Me);return t.clonedElement=e,t}(function(e){let t=an[e];if(ee(t)){t=document.createDocumentFragment();const n=sn(e);t.appendChild(n),an[e]=t}return t.cloneNode(!0).firstChild}(t))}}var fn;!function(e){e.REHYDRATE="lwc-rehydrate",e.HYDRATE="lwc-hydrate"}(fn||(fn={}));const hn="undefined"!=typeof performance&&"function"==typeof performance.mark&&"function"==typeof performance.clearMarks&&"function"==typeof performance.measure&&"function"==typeof performance.clearMeasures;function pn(e,t){return`${je(t)} - ${e} - ${t.idx}`}function mn(e){performance.mark(e)}function gn(e,t){performance.measure(e,t),performance.clearMarks(t),performance.clearMarks(e)}function yn(){}const bn=hn?function(e,t){mn(pn(e,t))}:yn,vn=hn?function(e,t){const n=pn(e,t);gn(function(e,t){return`${je(t)} - ${e}`}(e,t),n)}:yn,wn=hn?function(e,t){mn(ee(t)?e:pn(e,t))}:yn,$n=hn?function(e,t){gn(e,ee(t)?e:pn(e,t))}:yn;let Tn=!1,En=null;function kn(){return En}function Cn(e){En=e}const xn=x(null);function On(e,t){k.isTrue(re(t),`evaluateTemplate() second argument must be an imported template instead of ${le(t)}`);const n=Tn,o=En;let r=[];return Zr(e,e.owner,()=>{En=e,bn("render",e)},()=>{const{component:n,context:o,cmpSlots:a,cmpTemplate:i,tro:s}=e;s.observe(()=>{if(t!==i){if(ee(i)||Xr(e),ee(t)||(s=t,!on.has(s)))throw new TypeError(`Invalid template returned by the render() method on ${e}. It must return an imported template (e.g.: \`import html from "./${e.def.name}.html"\`), instead, it has returned: ${le(t)}.`);e.cmpTemplate=t,o.tplCache=x(null),function(e){const{context:t,elm:n}=e,o=t.hostAttribute;ee(o)||p.call(n,o),t.hostAttribute=t.shadowAttribute=void 0}(e);const{stylesheets:n,stylesheetTokens:r}=t;if(ee(n)||0===n.length)o.styleVNode=null;else if(!ee(r)){const{hostAttribute:t,shadowAttribute:a}=r;!function(e,t,n){const{context:o,elm:r}=e;f.call(r,t,""),o.hostAttribute=t,o.shadowAttribute=n}(e,t,a),o.styleVNode=dn(n,t,a)}(function(e,t){const{component:n}=e,{ids:o=[]}=t;_.call(o,t=>{t in n||De(`The template rendered by ${e} references \`this.${t}\`, which is not declared. Check for a typo in the template.`,e)})})(e,t)}var s;k.isTrue(ae(o.tplCache),`vm.context.tplCache must be an object associated to ${i}.`),function(e,t){const{cmpSlots:n=xn}=e,{slots:o=Me}=t;for(const t in n)k.isTrue(N(n[t]),`Slots can only be set to an array, instead received ${le(n[t])} for slot "${t}" in ${e}.`),""!==t&&-1===B.call(o,t)&&De(`Ignoring unknown provided slot name "${t}" in ${e}. Check for a typo on the slot attribute.`,e)}(e,t),e.velements=[],Tn=!0,r=t.call(void 0,nn,n,a,o.tplCache);const{styleVNode:l}=o;te(l)||G.call(r,l)})},()=>{Tn=n,En=o,vn("render",e)}),k.invariant(N(r),"Compiler should produce html functions that always return an array."),r}let Sn=!1,An=null;function Mn(e){return An===e}let Ln=null;const Pn=()=>{};function In(e,t,n){const{component:o,callHook:r,owner:a}=e;let i;return Zr(e,a,Pn,()=>{i=r(o,t,n)},Pn),i}function Rn(e,t,n,o){const{callHook:r,owner:a}=e;Zr(e,a,Pn,()=>{k.isTrue(re(t),`Invalid event handler for event '${o.type}' on ${e}.`),r(n,t,[o])},Pn)}const{create:Hn}=Object,{splice:jn,indexOf:Nn,push:Dn}=Array.prototype,Fn=new WeakMap;function _n(e){return void 0===e}let Bn=null;function Vn(e,t){const n=Fn.get(e);if(!_n(n)){const e=n[t];if(!_n(e))for(let t=0,n=e.length;t<n;t+=1){e[t].notify()}}}function qn(e,t){if(null===Bn)return;const n=Bn,o=function(e){let t=Fn.get(e);if(_n(t)){const n=Hn(null);t=n,Fn.set(e,n)}return t}(e);let r=o[t];if(_n(r))r=[],o[t]=r;else if(r[0]===n)return;-1===Nn.call(r,n)&&n.link(r)}class Un{constructor(e){this.listeners=[],this.callback=e}observe(e){const t=Bn;let n;Bn=this;try{e()}catch(e){n=Object(e)}finally{if(Bn=t,void 0!==n)throw n}}reset(){const{listeners:e}=this,t=e.length;if(t>0){for(let n=0;n<t;n+=1){const t=e[n],o=Nn.call(e[n],this);jn.call(t,o,1)}e.length=0}}notify(){this.callback.call(void 0,this)}link(e){Dn.call(e,this),Dn.call(this.listeners,e)}}const Wn=new Map;function zn(e,t){if(function(e,t){const n=An;let o;bn("constructor",e),An=e;try{const r=new t;if(An.component!==r)throw new TypeError("Invalid component constructor, the class should extend LightningElement.")}catch(e){o=Object(e)}finally{if(vn("constructor",e),An=n,!ee(o))throw o.wcStack=Ne(e),o}}(e,t),ee(e.component))throw new ReferenceError(`Invalid construction for ${t}, you must extend LightningElement.`)}function Kn(e){return new Un(()=>{k.invariant(!Sn,`Mutating property is not allowed during the rendering life-cycle of ${kn()}.`),k.invariant(!Tn,`Mutating property is not allowed while updating template of ${kn()}.`);const{isDirty:t}=e;oe(t)&&(Gn(e),function(e){e.isScheduled||(e.isScheduled=!0,0===Yr.length&&Pe(Gr),U.call(Yr,e))}(e))})}function Yn(e){k.invariant(e.isDirty,`${e} is not dirty.`),e.tro.reset();const t=function(e){const{def:{render:t},callHook:n,component:o,owner:r}=e,a=Sn,i=kn();let s,l=!1;return Zr(e,r,()=>{Sn=!0,Cn(e)},()=>{e.tro.observe(()=>{s=n(o,t),l=!0})},()=>{Sn=a,Cn(i)}),l?On(e,s):[]}(e);return e.isDirty=!1,e.isScheduled=!1,k.invariant(N(t),`${e}.render() should always return an array of vnodes instead of ${t}`),t}function Gn(e){{const t=kn();k.isFalse(e.isDirty,`markComponentAsDirty() for ${e} should not be called when the component is already dirty.`),k.isFalse(Sn,`markComponentAsDirty() for ${e} cannot be called during rendering of ${t}.`),k.isFalse(Tn,`markComponentAsDirty() for ${e} cannot be called while updating template of ${t}.`)}e.isDirty=!0}const Jn=new WeakMap;function Qn(e,t){if(!re(t))throw new TypeError;let n=Jn.get(t);return ee(n)&&(n=function(n){Rn(e,t,void 0,n)},Jn.set(t,n)),n}function Xn(e){return W.call(e,(e,t)=>{var n;return e[t]=(n=t,{get(){const e=Wr(this);return qn(this,n),e.cmpTrack[n]},set(e){const t=Wr(this);e!==t.cmpTrack[n]&&(t.cmpTrack[n]=e,oe(t.isDirty)&&Vn(this,n))},enumerable:!0,configurable:!0}),e},{})}const Zn=x(null);_.call(E,e=>{const t=ce(HTMLElement.prototype,e);ee(t)||(Zn[e]=t)}),_.call(ge,e=>{const t=ce(HTMLElement.prototype,e);ee(t)||(Zn[e]=t)});const eo=M(ShadowRoot.prototype,"innerHTML").set,to="EventTarget"in window?EventTarget.prototype.dispatchEvent:Node.prototype.dispatchEvent;function no(e){return Wr(e).elm}function oo(){if(te(An))throw new ReferenceError("Illegal constructor");k.invariant(An.elm instanceof HTMLElement,`Component creation requires a DOM element to be associated to ${An}.`);const e=An,{elm:t,mode:n,def:{ctor:o}}=e,r=this;if(e.component=r,e.tro=Kn(e),e.oar=x(null),1===arguments.length){const{callHook:t,setHook:n,getHook:o}=arguments[0];e.callHook=t,e.setHook=n,e.getHook=o}const a={mode:n,delegatesFocus:!!o.delegatesFocus,"$$lwc-synthetic-mode$$":!0},i=t.attachShadow(a);return Ur(r,e),Ur(i,e),Ur(t,e),e.cmpRoot=i,Ct(r),Et(i,Ae),this}oo.prototype={constructor:oo,dispatchEvent(e){const t=no(this);return to.apply(t,arguments)},addEventListener(e,t,n){const o=Wr(this);{const n=kn();k.invariant(!Sn,`${n}.render() method has side effects on the state of ${o} by adding an event listener for "${e}".`),k.invariant(!Tn,`Updating the template of ${n} has side effects on the state of ${o} by adding an event listener for "${e}".`),k.invariant(re(t),`Invalid second argument for this.addEventListener() in ${o} for event "${e}". Expected an EventListener but received ${t}.`)}const r=Qn(o,t);o.elm.addEventListener(e,r,n)},removeEventListener(e,t,n){const o=Wr(this),r=Qn(o,t);o.elm.removeEventListener(e,r,n)},setAttributeNS(e,t,n){const o=no(this);{const e=Wr(this);k.isFalse(Mn(e),`Failed to construct '${je(e)}': The result must not have attributes.`)}Oe(o,t),o.setAttributeNS.apply(o,arguments),xe()},removeAttributeNS(e,t){const n=no(this);Oe(n,t),n.removeAttributeNS.apply(n,arguments),xe()},removeAttribute(e){const t=no(this);Oe(t,e),t.removeAttribute.apply(t,arguments),xe()},setAttribute(e,t){const n=no(this);{const e=Wr(this);k.isFalse(Mn(e),`Failed to construct '${je(e)}': The result must not have attributes.`)}Oe(n,e),n.setAttribute.apply(n,arguments),xe()},getAttribute(e){const t=no(this);Oe(t,e);const n=t.getAttribute.apply(t,arguments);return xe(),n},getAttributeNS(e,t){const n=no(this);Oe(n,t);const o=n.getAttributeNS.apply(n,arguments);return xe(),o},getBoundingClientRect(){const e=no(this);{const e=Wr(this);k.isFalse(Mn(e),`this.getBoundingClientRect() should not be called during the construction of the custom element for ${je(e)} because the element is not yet in the DOM, instead, you can use it in one of the available life-cycle hooks.`)}return e.getBoundingClientRect()},querySelector(e){const t=Wr(this);k.isFalse(Mn(t),`this.querySelector() cannot be called during the construction of the custom element for ${je(t)} because no children has been added to this element yet.`);const{elm:n}=t;return n.querySelector(e)},querySelectorAll(e){const t=Wr(this);k.isFalse(Mn(t),`this.querySelectorAll() cannot be called during the construction of the custom element for ${je(t)} because no children has been added to this element yet.`);const{elm:n}=t;return n.querySelectorAll(e)},getElementsByTagName(e){const t=Wr(this);k.isFalse(Mn(t),`this.getElementsByTagName() cannot be called during the construction of the custom element for ${je(t)} because no children has been added to this element yet.`);const{elm:n}=t;return n.getElementsByTagName(e)},getElementsByClassName(e){const t=Wr(this);k.isFalse(Mn(t),`this.getElementsByClassName() cannot be called during the construction of the custom element for ${je(t)} because no children has been added to this element yet.`);const{elm:n}=t;return n.getElementsByClassName(e)},get isConnected(){const e=Wr(this),{elm:t}=e;return t.isConnected},get classList(){{const e=Wr(this);k.isFalse(Mn(e),`Failed to construct ${e}: The result must not have attributes. Adding or tampering with classname in constructor is not allowed in a web component, use connectedCallback() instead.`)}return no(this).classList},get template(){return Wr(this).cmpRoot},get shadowRoot(){return null},render(){return Wr(this).def.template},toString(){return`[object ${Wr(this).def.name}]`}};const ro=W.call(L(Zn),(e,t)=>(e[t]=function(e,t){const{get:n,set:o,enumerable:r,configurable:a}=t;if(!re(n))throw k.fail(`Detected invalid public property descriptor for HTMLElement.prototype.${e} definition. Missing the standard getter.`),new TypeError;if(!re(o))throw k.fail(`Detected invalid public property descriptor for HTMLElement.prototype.${e} definition. Missing the standard setter.`),new TypeError;return{enumerable:r,configurable:a,get(){const t=Wr(this);if(!Mn(t))return qn(this,e),n.call(t.elm);{const n=t.elm.constructor.name;De(`\`${n}\` constructor can't read the value of property \`${e}\` because the owner component hasn't set the value yet. Instead, use the \`${n}\` constructor to set a default value for the property.`,t)}},set(t){const n=Wr(this);{const o=kn();k.invariant(!Sn,`${o}.render() method has side effects on the state of ${n}.${e}`),k.invariant(!Tn,`When updating the template of ${o}, one of the accessors used by the template has side effects on the state of ${n}.${e}`),k.isFalse(Mn(n),`Failed to construct '${je(n)}': The result must not have attributes.`),k.invariant(!ae(t)||te(t),`Invalid value "${t}" for "${e}" of ${n}. Value cannot be an object, must be a primitive value.`)}return t!==n.cmpProps[e]&&(n.cmpProps[e]=t,oe(n.isDirty)&&Vn(this,e)),o.call(n.elm,t)}}}(t,Zn[t]),e),x(null));var ao;O(oo.prototype,ro),ao=oo.prototype,O(ao,wt(ao)),A(oo),H(oo.prototype);const io=oo,{isArray:so}=Array,{getPrototypeOf:lo,create:co,defineProperty:uo,defineProperties:fo,isExtensible:ho,getOwnPropertyDescriptor:po,getOwnPropertyNames:mo,getOwnPropertySymbols:go,preventExtensions:yo,hasOwnProperty:bo}=Object,{push:vo,concat:wo,map:$o}=Array.prototype,To={}.toString;function Eo(e){return void 0===e}function ko(e){return"function"==typeof e}const Co=new WeakMap;function xo(e,t){Co.set(e,t)}const Oo=e=>Co.get(e)||e;function So(e,t){return e.valueIsObservable(t)?e.getProxy(t):t}function Ao(e,t,n){wo.call(mo(n),go(n)).forEach(o=>{let r=po(n,o);r.configurable||(r=Bo(e,r,So)),uo(t,o,r)}),yo(t)}class Mo{constructor(e,t){this.originalTarget=t,this.membrane=e}get(e,t){const{originalTarget:n,membrane:o}=this,r=n[t],{valueObserved:a}=o;return a(n,t),o.getProxy(r)}set(e,t,n){const{originalTarget:o,membrane:{valueMutated:r}}=this;return o[t]!==n?(o[t]=n,r(o,t)):"length"===t&&so(o)&&r(o,t),!0}deleteProperty(e,t){const{originalTarget:n,membrane:{valueMutated:o}}=this;return delete n[t],o(n,t),!0}apply(e,t,n){}construct(e,t,n){}has(e,t){const{originalTarget:n,membrane:{valueObserved:o}}=this;return o(n,t),t in n}ownKeys(e){const{originalTarget:t}=this;return wo.call(mo(t),go(t))}isExtensible(e){const t=ho(e);if(!t)return t;const{originalTarget:n,membrane:o}=this,r=ho(n);return r||Ao(o,e,n),r}setPrototypeOf(e,t){throw new Error(`Invalid setPrototypeOf invocation for reactive proxy ${n=this.originalTarget,n&&n.toString?n.toString():"object"==typeof n?To.call(n):n+""}. Prototype of reactive objects cannot be changed.`);var n}getPrototypeOf(e){const{originalTarget:t}=this;return lo(t)}getOwnPropertyDescriptor(e,t){const{originalTarget:n,membrane:o}=this,{valueObserved:r}=this.membrane;r(n,t);let a=po(n,t);if(Eo(a))return a;const i=po(e,t);return Eo(i)?(a=Bo(o,a,So),a.configurable||uo(e,t,a),a):i}preventExtensions(e){const{originalTarget:t,membrane:n}=this;return Ao(n,e,t),yo(t),!0}defineProperty(e,t,n){const{originalTarget:o,membrane:r}=this,{valueMutated:a}=r,{configurable:i}=n;if(bo.call(n,"writable")&&!bo.call(n,"value")){const e=po(o,t);n.value=e.value}return uo(o,t,function(e){return bo.call(e,"value")&&(e.value=Oo(e.value)),e}(n)),!1===i&&uo(e,t,Bo(r,n,So)),a(o,t),!0}}function Lo(e,t){return e.valueIsObservable(t)?e.getReadOnlyProxy(t):t}class Po{constructor(e,t){this.originalTarget=t,this.membrane=e}get(e,t){const{membrane:n,originalTarget:o}=this,r=o[t],{valueObserved:a}=n;return a(o,t),n.getReadOnlyProxy(r)}set(e,t,n){{const{originalTarget:e}=this;throw new Error(`Invalid mutation: Cannot set "${t.toString()}" on "${e}". "${e}" is read-only.`)}}deleteProperty(e,t){{const{originalTarget:e}=this;throw new Error(`Invalid mutation: Cannot delete "${t.toString()}" on "${e}". "${e}" is read-only.`)}}apply(e,t,n){}construct(e,t,n){}has(e,t){const{originalTarget:n,membrane:{valueObserved:o}}=this;return o(n,t),t in n}ownKeys(e){const{originalTarget:t}=this;return wo.call(mo(t),go(t))}setPrototypeOf(e,t){{const{originalTarget:e}=this;throw new Error(`Invalid prototype mutation: Cannot set prototype on "${e}". "${e}" prototype is read-only.`)}}getOwnPropertyDescriptor(e,t){const{originalTarget:n,membrane:o}=this,{valueObserved:r}=o;r(n,t);let a=po(n,t);if(Eo(a))return a;const i=po(e,t);return Eo(i)?(a=Bo(o,a,Lo),bo.call(a,"set")&&(a.set=void 0),a.configurable||uo(e,t,a),a):i}preventExtensions(e){{const{originalTarget:e}=this;throw new Error(`Invalid mutation: Cannot preventExtensions on ${e}". "${e} is read-only.`)}}defineProperty(e,t,n){{const{originalTarget:e}=this;throw new Error(`Invalid mutation: Cannot defineProperty "${t.toString()}" on "${e}". "${e}" is read-only.`)}}}const Io={header:e=>{const t=Oo(e);return t&&t!==e?["object",{object:function e(t){if(so(t))return t.map(t=>{const n=Oo(t);return n!==t?e(n):t});const n=co(lo(t)),o=mo(t);return wo.call(o,go(t)).reduce((n,o)=>{const r=t[o],a=Oo(r);return n[o]=a!==r?e(a):r,n},n)}(e)}]:null},hasBody:()=>!1,body:()=>null};function Ro(){return"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:void 0!==e?e:{}}function Ho(e){let t=void 0;return so(e)?t=[]:"object"==typeof e&&(t={}),t}(function(){const e=Ro(),t=e.devtoolsFormatters||[];vo.call(t,Io),e.devtoolsFormatters=t})();const jo=Object.prototype;function No(e){if(null===e)return!1;if("object"!=typeof e)return!1;if(so(e))return!0;const t=lo(e);return t===jo||null===t||null===lo(t)}const Do=(e,t)=>{},Fo=(e,t)=>{},_o=e=>e;function Bo(e,t,n){const{set:o,get:r}=t;return bo.call(t,"value")?t.value=n(e,t.value):(Eo(r)||(t.get=function(){return n(e,r.call(Oo(this)))}),Eo(o)||(t.set=function(t){o.call(Oo(this),e.unwrapProxy(t))})),t}function Vo(e){return e}const qo=new class{constructor(e){if(this.valueDistortion=_o,this.valueMutated=Fo,this.valueObserved=Do,this.valueIsObservable=No,this.objectGraph=new WeakMap,!Eo(e)){const{valueDistortion:t,valueMutated:n,valueObserved:o,valueIsObservable:r}=e;this.valueDistortion=ko(t)?t:_o,this.valueMutated=ko(n)?n:Fo,this.valueObserved=ko(o)?o:Do,this.valueIsObservable=ko(r)?r:No}}getProxy(e){const t=Oo(e),n=this.valueDistortion(t);if(this.valueIsObservable(n)){const o=this.getReactiveState(t,n);return o.readOnly===e?e:o.reactive}return n}getReadOnlyProxy(e){e=Oo(e);const t=this.valueDistortion(e);return this.valueIsObservable(t)?this.getReactiveState(e,t).readOnly:t}unwrapProxy(e){return Oo(e)}getReactiveState(e,t){const{objectGraph:n}=this;let o=n.get(t);if(o)return o;const r=this;return o={get reactive(){const n=new Mo(r,t),o=new Proxy(Ho(t),n);return xo(o,e),uo(this,"reactive",{value:o}),o},get readOnly(){const n=new Po(r,t),o=new Proxy(Ho(t),n);return xo(o,e),uo(this,"readOnly",{value:o}),o}},n.set(t,o),o}}({valueObserved:qn,valueMutated:Vn,valueDistortion:Vo}),Uo=x(null),Wo=x(null);function zo(e){let t=Uo[e];return ee(t)&&(t=Uo[e]=function(){const t=Wr(this),{getHook:n}=t;return n(t.component,e)}),t}function Ko(e){let t=Wo[e];return ee(t)&&(t=Wo[e]=function(t){const n=Wr(this),{setHook:o}=n;t=qo.getReadOnlyProxy(t),o(n.component,e,t)}),t}function Yo(e){return function(){const t=Wr(this),{callHook:n,component:o}=t,r=o[e];return n(t.component,r,K.call(arguments))}}function Go(e,t,n){let o;re(e)?o=class extends e{}:(o=function(){throw new TypeError("Illegal constructor")},j(o,e),j(o.prototype,e.prototype),S(o.prototype,"constructor",{writable:!0,configurable:!0,value:o}));const r=x(null);for(let e=0,n=t.length;e<n;e+=1){const n=t[e];r[n]={get:zo(n),set:Ko(n),enumerable:!0,configurable:!0}}for(let e=0,t=n.length;e<t;e+=1){const t=n[e];r[t]={value:Yo(t),writable:!0,configurable:!0}}return O(o.prototype,r),o}const Jo=Go(HTMLElement,L(Zn),[]);function Qo(e,t,n){if(1===arguments.length)return qo.getProxy(e);if(3!==arguments.length&&k.fail("@track decorator can only be used with one argument to return a trackable object, or as a decorator function."),!ee(n)){const{get:e,set:t,configurable:o,writable:r}=n;k.isTrue(!e&&!t,"Compiler Error: A @track decorator can only be applied to a public field."),k.isTrue(!1!==o,"Compiler Error: A @track decorator can only be applied to a configurable property."),k.isTrue(!1!==r,"Compiler Error: A @track decorator can only be applied to a writable property.")}return Xo(e,t,!!ee(n)||!0===n.enumerable)}function Xo(e,t,n){return{get(){const e=Wr(this);return qn(this,t),e.cmpTrack[t]},set(e){const n=Wr(this);{const e=kn();k.invariant(!Sn,`${e}.render() method has side effects on the state of ${n}.${le(t)}`),k.invariant(!Tn,`Updating the template of ${e} has side effects on the state of ${n}.${le(t)}`)}const o=qo.getProxy(e);o!==n.cmpTrack[t]&&(n.cmpTrack[t]=o,oe(n.isDirty)&&Vn(this,t))},enumerable:n,configurable:!0}}function Zo(e,t,n){if(!ee(n)){const{get:e,set:t,configurable:o,writable:r}=n;k.isTrue(!e&&!t,"Compiler Error: A @wire decorator can only be applied to a public field."),k.isTrue(!1!==o,"Compiler Error: A @wire decorator can only be applied to a configurable property."),k.isTrue(!1!==r,"Compiler Error: A @wire decorator can only be applied to a writable property.")}return Xo(0,t,!ae(n)||!0===n.enumerable)}function er(e,t){const n=arguments.length;if(n>0&&n<3)return Zo;throw k.fail("@wire(adapter, config?) may only be used as a decorator."),new TypeError}A(Jo),H(Jo.prototype);const{assign:tr,create:nr,defineProperties:or,defineProperty:rr,freeze:ar,getOwnPropertyDescriptor:ir,getOwnPropertyNames:sr,getPrototypeOf:lr,hasOwnProperty:cr,keys:ur,seal:dr,setPrototypeOf:fr}=Object;function hr(e){return void 0===e}Symbol("x").toString();let pr;"object"==typeof globalThis&&(pr=globalThis);const mr=function(){if("object"==typeof pr)return pr;try{Object.defineProperty(Object.prototype,"__magic__",{get:function(){return this},configurable:!0}),pr=__magic__,delete Object.prototype.__magic__}catch(e){}finally{void 0===pr&&(pr=window)}return pr}();mr.lwcRuntimeFlags||Object.defineProperty(mr,"lwcRuntimeFlags",{value:nr(null)});const gr=mr.lwcRuntimeFlags;function yr(e,t){if(!(!0===t||function(e){return!1===e}(t))){const n=`Failed to set the value "${t}" for the runtime feature flag "${e}". Runtime feature flags can only be set to a boolean value.`;throw new TypeError(n)}hr(br[e])?console.warn(`Failed to set the value "${t}" for the runtime feature flag "${e}" because it is undefined. Possible reasons are that 1) it was misspelled or 2) it was removed from the @lwc/features package.`):gr[e]=t}const br={ENABLE_REACTIVE_SETTER:null,ENABLE_ELEMENT_PATCH:null,ENABLE_NODE_LIST_PATCH:null,ENABLE_HTML_COLLECTIONS_PATCH:null,ENABLE_NODE_PATCH:null};function vr(e,t,n){3!==arguments.length&&k.fail("@api decorator can only be used as a decorator function."),k.invariant(!n||re(n.get)||re(n.set),`Invalid property ${le(t)} definition in ${e}, it cannot be a prototype definition if it is a public property. Instead use the constructor to define it.`),ae(n)&&re(n.set)&&k.isTrue(ae(n)&&re(n.get),`Missing getter for property ${le(t)} decorated with @api in ${e}. You cannot have a setter without the corresponding getter.`);const o=Cr(e);return ae(n)&&(re(n.get)||re(n.set))?(o.props[t].config=re(n.set)?3:1,Tr(e,t,n)):(o.props[t].config=0,wr(e,t,n))}function wr(e,t,n){return{get(){const e=Wr(this);if(!Mn(e))return qn(this,t),e.cmpProps[t];{const n=e.elm.constructor.name;De(`\`${n}\` constructor can’t read the value of property \`${le(t)}\` because the owner component hasn’t set the value yet. Instead, use the \`${n}\` constructor to set a default value for the property.`,e)}},set(e){const n=Wr(this);{const e=kn();k.invariant(!Sn,`${e}.render() method has side effects on the state of ${n}.${le(t)}`),k.invariant(!Tn,`Updating the template of ${e} has side effects on the state of ${n}.${le(t)}`)}n.cmpProps[t]=e,oe(n.isDirty)&&Vn(this,t)},enumerable:!!ee(n)||n.enumerable}}class $r extends Un{constructor(e,t){super(()=>{oe(this.debouncing)&&(this.debouncing=!0,Pe(()=>{if(ne(this.debouncing)){const{value:n}=this,{isDirty:o,component:r,idx:a}=e;t.call(r,n),this.debouncing=!1,ne(e.isDirty)&&oe(o)&&a>0&&Dr(e)}}))}),this.debouncing=!1}reset(e){super.reset(),this.debouncing=!1,arguments.length>0&&(this.value=e)}}function Tr(e,t,n){const{get:o,set:r,enumerable:a}=n;if(!re(o))throw k.fail(`Invalid attempt to create public property descriptor ${le(t)} in ${e}. It is missing the getter declaration with @api get ${le(t)}() {} syntax.`),new TypeError;return{get(){return Wr(this),o.call(this)},set(e){const n=Wr(this);{const e=kn();k.invariant(!Sn,`${e}.render() method has side effects on the state of ${n}.${le(t)}`),k.invariant(!Tn,`Updating the template of ${e} has side effects on the state of ${n}.${le(t)}`)}if(r)if(gr.ENABLE_REACTIVE_SETTER){let o=n.oar[t];ee(o)&&(o=n.oar[t]=new $r(n,r)),o.reset(e),o.observe(()=>{r.call(this,e)})}else r.call(this,e);else k.fail(`Invalid attempt to set a new value for property ${le(t)} of ${n} that does not has a setter decorated with @api.`)},enumerable:a}}function Er(e,t){if(!re(e)||null==t)throw new TypeError;const n=L(t),o=e.prototype;for(let r=0,a=n.length;r<a;r+=1){const a=n[r],i=t[a];if(!re(i))throw new TypeError;const s=i(e,a,M(o,a));ee(s)||S(o,a,s)}return e}const kr=new Map;function Cr(e){return kr.get(e)}const xr=new WeakMap;function Or(e,t,n){{const t=e.name;k.isTrue(e.constructor,`Missing ${t}.constructor, ${t} should have a "constructor" property.`)}const{name:o}=t;let{template:r}=t;const a=Cr(e);let i,s,l={},c={},u={};ee(a)||(l=a.props,c=a.methods,i=a.wire,u=a.track,s=a.fields);const d=e.prototype;let{connectedCallback:f,disconnectedCallback:h,renderedCallback:p,errorCallback:m,render:g}=d;const y=function(e,t){let n=P(e);if(te(n))throw new ReferenceError(`Invalid prototype chain for ${t}, you must extend LightningElement.`);if(Ie(n)){const e=Re(n);if(te(e))throw new ReferenceError(`Circular module dependency for ${t}, must resolve to a constructor that extends LightningElement.`);n=e===n?io:e}return n}(e,n),b=y!==io?Ar(y,n):null,v=Go(te(b)?Jo:b.bridge,L(l),L(c));te(b)||(l=C(x(null),b.props,l),c=C(x(null),b.methods,c),i=b.wire||i?C(x(null),b.wire,i):void 0,u=C(x(null),b.track,u),f=f||b.connectedCallback,h=h||b.disconnectedCallback,p=p||b.renderedCallback,m=m||b.errorCallback,g=g||b.render,r=r||b.template),l=C(x(null),Lr,l),ee(s)||O(d,Xn(s)),ee(r)&&(r=rn);const w={ctor:e,name:o,wire:i,track:u,props:l,methods:c,bridge:v,template:r,connectedCallback:f,disconnectedCallback:h,renderedCallback:p,errorCallback:m,render:g};return A(e.prototype),w}function Sr(e){if(!re(e))return!1;if(e.prototype instanceof io)return!0;let t=e;do{if(Ie(t)){const e=Re(t);if(e===t)return!0;t=e}if(t===io)return!0}while(!te(t)&&(t=P(t)));return!1}function Ar(e,t){let n=xr.get(e);if(ee(n)){if(!Sr(e))throw new TypeError(`${e} is not a valid component, or does not extends LightningElement from "lwc". You probably forgot to add the extend clause on the class declaration.`);let o=function(e){return Wn.get(e)}(e);ee(o)&&(o={template:void 0,name:e.name}),n=Or(e,o,t||e.name),xr.set(e,n)}return n}function Mr(e,t){j(e,t.bridge.prototype)}const Lr=W.call(L(Zn),(e,t)=>{const n=Ee(t);return e[t]={config:3,type:"any",attr:n},e},x(null));var Pr;!function(e){e[e.created=0]="created",e[e.connected=1]="connected",e[e.disconnected=2]="disconnected"}(Pr||(Pr={}));let Ir=0;const Rr=fe("ViewModel","engine");function Hr(e,t,n=[]){return t.apply(e,n)}function jr(e,t,n){e[t]=n}function Nr(e,t){return e[t]}function Dr(e){Kr(e)}function Fr(e){Jr(e),Kr(e)}function _r(e){const{state:t}=e;if(t!==Pr.disconnected){const{oar:t,tro:n}=e;n.reset();for(const e in t)t[e].reset();!function(e){k.isTrue(e.state!==Pr.disconnected,`${e} must be inserted.`);oe(e.isDirty)&&(e.isDirty=!0);e.state=Pr.disconnected;const{disconnected:t}=Ft;t&&Bt(e,t);const{disconnectedCallback:n}=e.def;ee(n)||(bn("disconnectedCallback",e),In(e,n),vn("disconnectedCallback",e))}(e),Qr(e),function(e){const{aChildren:t}=e;!function e(t){for(let n=0,o=t.length;n<o;n+=1){const o=t[n];te(o)||!N(o.children)||ee(o.elm)||(ee(o.ctor)?e(o.children):_r(Wr(o.elm)))}}(t)}(e)}}function Br(e){_r(e)}function Vr(e,t,n){k.invariant(e instanceof HTMLElement,`VM creation requires a DOM element instead of ${e}.`);const o=Ar(t),{isRoot:r,mode:a,owner:i}=n;Ir+=1;const s={idx:Ir,state:Pr.created,isScheduled:!1,isDirty:!0,isRoot:ne(r),mode:a,def:o,owner:i,elm:e,data:Ae,context:x(null),cmpProps:x(null),cmpTrack:x(null),cmpSlots:He?x(null):void 0,callHook:Hr,setHook:jr,getHook:Nr,children:Me,aChildren:Me,velements:Me,cmpTemplate:void 0,component:void 0,cmpRoot:void 0,tro:void 0,oar:void 0,toString:()=>`[object:vm ${o.name} (${s.idx})]`};zn(s,t),function(e){const{def:{wire:t}}=e;if(!ee(t)){const{wiring:t}=Ft;t&&Bt(e,t)}}(s)}function qr(e){if(te(e)||!ae(e)||!("cmpRoot"in e))throw new TypeError(`${e} is not a VM.`)}function Ur(e,t){pe(e,Rr,t)}function Wr(e){const t=me(e,Rr);return qr(t),t}function zr(e){const t=me(e,Rr);return ee(t)||qr(t),t}function Kr(e){if(k.isTrue(e.elm instanceof HTMLElement,`rehydration can only happen after ${e} was patched the first time.`),ne(e.isDirty)){!function(e,t){const{cmpRoot:n,children:o}=e;if(e.children=t,(t.length>0||o.length>0)&&o!==t){const r=Dt(t)?ut:dt;Zr(e,e,()=>{bn("patch",e)},()=>{r(n,o,t)},()=>{vn("patch",e)})}e.state===Pr.connected&&function(e){const{rendered:t}=Ft;t&&Bt(e,t);!function(e){const{def:{renderedCallback:t},component:n,callHook:o,owner:r}=e;if(!ee(t)){const a=Ln;Zr(e,r,()=>{Ln=e,bn("renderedCallback",e)},()=>{o(n,t)},()=>{vn("renderedCallback",e),Ln=a})}}(e)}(e)}(e,Yn(e))}}let Yr=[];function Gr(){wn(fn.REHYDRATE),k.invariant(Yr.length,`If rehydrateQueue was scheduled, it is because there must be at least one VM on this pending queue instead of ${Yr}.`);const e=Yr.sort((e,t)=>e.idx-t.idx);Yr=[];for(let t=0,n=e.length;t<n;t+=1){const o=e[t];try{Kr(o)}catch(o){throw t+1<n&&(0===Yr.length&&Pe(Gr),G.apply(Yr,K.call(e,t+1))),$n(fn.REHYDRATE),o}}$n(fn.REHYDRATE)}function Jr(e){const{state:t}=e;if(t===Pr.connected)return;e.state=Pr.connected;const{connected:n}=Ft;n&&Bt(e,n);const{connectedCallback:o}=e.def;ee(o)||(bn("connectedCallback",e),In(e,o),vn("connectedCallback",e))}function Qr(e){const{velements:t}=e;for(let e=t.length-1;e>=0;e-=1){const n=t[e].elm;if(!ee(n)){_r(Wr(n))}}}function Xr(e){e.children=Me,eo.call(e.cmpRoot,""),Qr(e)}function Zr(e,t,n,o,r){let a;n();try{o()}catch(e){a=Object(e)}finally{if(r(),!ee(a)){a.wcStack=a.wcStack||Ne(e);const n=te(t)?void 0:function(e){let t=e;for(;!te(t);){if(!ee(t.def.errorCallback))return t;t=t.owner}}(t);if(ee(n))throw a;Xr(e),bn("errorCallback",n),In(n,n.def.errorCallback,[a,a.wcStack]),vn("errorCallback",n)}}}const{appendChild:ea,insertBefore:ta,removeChild:na,replaceChild:oa}=Node.prototype,ra=fe("connecting","engine"),aa=fe("disconnecting","engine");function ia(e,t){k.isTrue(e,"callNodeSlot() should not be called for a non-object");const n=me(e,t);return ee(n)||n(),e}C(Node.prototype,{appendChild(e){return ia(ea.call(this,e),ra)},insertBefore(e,t){return ia(ta.call(this,e,t),ra)},removeChild(e){return ia(na.call(this,e),aa)},replaceChild(e,t){const n=oa.call(this,e,t);return ia(n,aa),ia(e,ra),n}}),t.LightningElement=io,t.api=vr,t.buildCustomElementConstructor=function(e,t){var n;const{props:o,bridge:r}=Ar(e),a={mode:"open",isRoot:!0,owner:null};if(ae(t)&&!te(t)){const{mode:e}=t;"closed"===e&&(a.mode=e)}return(n=class extends r{constructor(){super(),Vr(this,e,a),kt(this,Ae)}connectedCallback(){Fr(Wr(this))}disconnectedCallback(){Br(Wr(this))}attributeChangedCallback(e,t,n){if(t===n)return;const r=function(e){return ee(ve[e])&&(ve[e]=Q.call(e,$e,e=>e[1].toUpperCase())),ve[e]}(e);ee(o[r])||function(e,t){return e!==Ce||t!==ke}(this,e)&&(this[r]=n)}}).observedAttributes=q.call(L(o),e=>o[e].attr),n},t.createElement=function(e,t){if(!ae(t)||te(t))throw new TypeError(`"createElement" function expects an object as second parameter but received "${le(t)}".`);let n=t.is;if(!re(n))throw new TypeError('"createElement" function expects a "is" option with a valid component constructor.');const o="closed"!==t.mode?"open":"closed",r=document.createElement(e);if(!ee(zr(r)))return r;Ie(n)&&(n=Re(n));const a=Ar(n);return Mr(r,a),kt(r,Ae),Vr(r,n,{mode:o,isRoot:!0,owner:null}),pe(r,ra,()=>{const e=Wr(r);wn(fn.HYDRATE,e),e.state===Pr.connected&&Br(e),Fr(e),$n(fn.HYDRATE,e)}),pe(r,aa,()=>{Br(Wr(r))}),r},t.decorate=Er,t.getComponentConstructor=function(e){let t=null;if(e instanceof HTMLElement){const n=zr(e);ee(n)||(t=n.def.ctor)}return t},t.getComponentDef=Ar,t.isComponentConstructor=Sr,t.isNodeFromTemplate=function(e){return!oe(e instanceof Node)&&(!(e instanceof ShadowRoot)&&((!He||!ee(e.$shadowResolver$))&&e.getRootNode()instanceof ShadowRoot))},t.readonly=function(e){return 1!==arguments.length&&k.fail("@readonly cannot be used as a decorator just yet, use it as a function with one argument to produce a readonly version of the provided value."),qo.getReadOnlyProxy(e)},t.register=function(e){k.isTrue(ae(e),`Invalid service declaration, ${e}: service must be an object`);for(let t=0;t<_t.length;++t){const n=_t[t];if(n in e){let t=Ft[n];ee(t)&&(Ft[n]=t=[]),U.call(t,e[n])}}},t.registerComponent=function(e,{name:t,tmpl:n}){return Wn.set(e,{name:t,template:n}),e},t.registerDecorators=function(e,t){const n=x(null),o=function(e,t){if(ee(t)||0===L(t).length)return Ae;return L(t).reduce((e,n)=>{const o=Ee(n);return e[n]=C({config:0,type:"any",attr:o},t[n]),e},x(null))}(0,t.publicProps),r=function(e,t){if(ee(t)||0===t.length)return Ae;return t.reduce((t,n)=>(k.isTrue(re(e.prototype[n]),`Component "${e.name}" should have a method \`${n}\` instead of ${e.prototype[n]}.`),t[n]=e.prototype[n],t),x(null))}(e,t.publicMethods),a=function(e,t){if(ee(t)||0===L(t).length)return;return C(x(null),t)}(0,t.wire),i=function(e,t){if(ee(t)||0===L(t).length)return Ae;return C(x(null),t)}(0,t.track),s=t.fields;kr.set(e,{props:o,methods:r,wire:a,track:i,fields:s});for(const e in o)n[e]=vr;if(a)for(const e in a){const t=a[e];t.method||(n[e]=er(t.adapter,t.params))}if(i)for(const e in i)n[e]=Qo;return Er(e,n),e},t.registerTemplate=function(e){return on.add(e),e},t.sanitizeAttribute=function(e,t,n,o){return o},t.setFeatureFlag=yr,t.setFeatureFlagForTest=function(e,t){return yr(e,t)},t.track=Qo,t.unwrap=function(e){const t=qo.unwrapProxy(e);return t!==e?t:e},t.wire=er}).call(this,n(2))}]]);